[{"uri":"http://localhost:8901/Scripts/Ch02.html","title":"Chapter 2","content":"(**\n---\ntitle: Chapter 2\ncategory: Scripts\ncategoryindex: 1\nindex: 2\n---\n*)\n\n#r \u0022nuget: FSharp.Stats, 0.4.6\u0022\n#r \u0022nuget: Plotly.NET, 3.0.0\u0022\n#r \u0022nuget: Plotly.NET.Interactive, 3.0.0\u0022\n\nopen FSharp.Stats\nopen FSharp.Stats.Distributions\nopen Plotly.NET\n\nlet computePosterior likelihood prior : list\u003Cfloat\u003E = \n    prior\n    |\u003E List.zip likelihood\n    |\u003E List.map (fun (likelihood_i, prior_i) -\u003E likelihood_i * prior_i)\n    |\u003E fun unstandardizedPosterior -\u003E \n        let sum = List.sum unstandardizedPosterior\n        unstandardizedPosterior |\u003E List.map (fun xs -\u003E xs / sum)\n\nlet gridApproximationFig (probas : list\u003Cfloat\u003E) (prior : list\u003Cfloat\u003E) (likelihood : list\u003Cfloat\u003E) : GenericChart.GenericChart = \n    [\n        Chart.Line(probas, prior, ShowMarkers=true, Name=\u0022Prior\u0022); \n        Chart.Line(probas, likelihood, ShowMarkers=true, Name=\u0022Likelihood\u0022); \n        Chart.Line(probas, computePosterior prior likelihood, ShowMarkers=true, Name=\u0022Posterior\u0022)\n    ] \n    |\u003E Chart.Grid(1, 3)\n    |\u003E Chart.withTitle($\u0022Grid approximation (n: {probas.Length})\u0022)\n    |\u003E Chart.withYAxisStyle(TitleText=\u0022Plausibility\u0022)\n    |\u003E Chart.withSize(1500.0, 500.0)\n\n// Grid approximation\nlet n = 50.\nlet probas = [0. .. (1. / n) .. 1.]\nlet flatPrior = [for _ in 0. .. n -\u003E 1.]\nlet likelihood = [for p in probas -\u003E (Discrete.binomial p 9).PDF 6]\n\n(**\nThe target of inference in Bayesian inference is a posterior probability distribution.\n*)\n\n(**\nPractice\n*)\n\n(**\nEasy\n*)\n\n(**\n2E1. Pr(rain|Monday)\n2E2. The probability that it is Monday, given that it is raining.\n2E3. Pr(Monday|rain); Pr(rain|Monday)Pr(Monday) / Pr(rain)\n2E4. \u0022the probability of water is 0.7\u0022 -\u003E Here, 0.7 represents the proportion of the globe that is covered in water.\n*)\n\n(**\nMedium\n*)\n\n(**\n2M1. Recall the globe tossing model from the chapter. Compute and plot the grid approximate\nposterior distribution for each of the following sets of observations.In each case, assume a uniform\nprior for p.\n(1) W,W,W\n(2) W,W,W,L\n(3) L,W,W,L,W,W,W\n*)\n\nlet multiGridApproximationFig priorFunc (points : list\u003Cint\u003E) (nTrials : int) (nSucesses : int)= \n    points\n    |\u003E List.map (fun nPointsToEstimate -\u003E \n        let probas = [0. .. (1. / (float nPointsToEstimate - 1.)) .. \n            if nTrials \u003C\u003E nSucesses then 1. \n            else 0.999999999999999]\n\n        let prior, likelihood = \n            probas \n            |\u003E List.map (fun p -\u003E \n                priorFunc p, (Discrete.binomial p nTrials).PDF nSucesses)\n            |\u003E List.unzip\n        \n        Chart.Line(probas, computePosterior likelihood prior, Name = $\u0022#Points: {probas.Length}\u0022))\n    |\u003E Chart.combine\n    |\u003E Chart.withTitle(\u0022Grid approximate posterior distribution\u0022)\n    |\u003E Chart.withXAxisStyle(\u0022Proportion of water (parameter p)\u0022)\n    |\u003E Chart.withYAxisStyle(\u0022Posterior probability\u0022)\n    |\u003E Chart.withSize(650., 650.)\n\n// (1) W,W,W\n// N = 3; W = 3 ; L = 0\nmultiGridApproximationFig (fun x -\u003E 1.) [10 .. 10 .. 100] 3 3\n\n// (2) W,W,W,L\n// N = 4; W = 3; L = 1\nmultiGridApproximationFig (fun x -\u003E 1.) [10 .. 10 .. 100] 4 3\n\n// (3) L,W,W,L,W,W,W\n// N = 7; W = 5; L = 2\nmultiGridApproximationFig (fun x -\u003E 1.) [10 .. 10 .. 100] 10 1\n\n(**\n2M2. Now assume a prior for p that is equal to zero when p \u003C 0.5 and is a positive constant when\np \u2265 0.5. Again compute and plot the grid approximate posterior distribution for each of the sets of\nobservations in the problem just above.\n*)\n\n// (1) W,W,W\n// N = 3; W = 3 ; L = 0\nmultiGridApproximationFig (fun x -\u003E if float x \u003C 0.5 then 0. else 1.) [10 .. 10 .. 100] 3 3 \n\n// (2) W,W,W,L\n// N = 4; W = 3; L = 1\nmultiGridApproximationFig (fun x -\u003E if float x \u003C 0.5 then 0. else 1.) [10 .. 10 .. 100] 4 3 \n\n// (3) L,W,W,L,W,W,W\n// N = 7; W = 5; L = 2\nmultiGridApproximationFig (fun x -\u003E if float x \u003C 0.5 then 0. else 1.) [10 .. 10 .. 100] 7 5 \n\n(**\n2M3. \nSuppose there are two globes, one for Earth and one for Mars. \nThe Earth globe is 70% covered in water. The Mars globe is 100% land. \nFurther suppose that one of these globes\u2014you don\u2019t know which\u2014was tossed in the air and produced a \u201Cland\u201D observation. \nAssume that each globe was equally likely to be tossed. Show that the posterior probability that the globe was the Earth, \nconditional on seeing \u201Cland\u201D (Pr(Earth|land)), is 0.23.\n\nPr(Earth|Land) = 0.23\nPr(Earth|Land) = Pr(Land|Earth) * Pr(Earth) / Pr(Land)\n*)\n\nlet prLandGivenEarth = 0.3\nlet prLandGivenMars = 1.\nlet prEarth = 0.5\nlet prMars = 0.5\n\nlet prLand = (prMars * prLandGivenMars) \u002B (prEarth * prLandGivenEarth)\nlet prEarthGivenLand = (prLandGivenEarth * prEarth) / (prLand)\n\n(**\n2M4.\n\n3 Cards - X, Y, Z\n2 Sides - B, W\n\nBB, BW, WW\n\n\n\n*)"},{"uri":"http://localhost:8901/Scripts/Ch03.html","title":"Chapter 3","content":"(**\n---\ntitle: Chapter 3\ncategory: Scripts\ncategoryindex: 1\nindex: 3\n---\n*)\n\n#load \u0022Common.fsx\u0022\n#r \u0022nuget: FSharp.Stats, 0.4.6\u0022\n#r \u0022nuget: Plotly.NET, 3.0.0\u0022\n#r \u0022nuget: Plotly.NET.Interactive, 3.0.0\u0022\n#r \u0022nuget: Numpy, 3.10.1.29\u0022\n#r \u0022nuget: Microsoft.Solver.Foundation, 3.1.0\u0022\n#r \u0022nuget: MathNet.Numerics, 5.0.0\u0022\n\nopen System\nopen Common\nopen Common.NumpyUtils\nopen FSharp.Stats\nopen Plotly.NET\nopen Numpy\nopen MathNet.Numerics\nopen MathNet.Numerics.Distributions\nopen Plotly.NET.LayoutObjects\n\n(**\n**Reconstructing the posterior distribution via sampling.**\n\n**Estimate posterior distribution with the Grid Approximation method**\n    - Choose n points to estimate\n    - Compute the likelihoods over a range of probabilities (parameter values) (binomial distribution)\n    - Adjust for the given prior (uniform, heavyside, etc ...)\n    - Standardize\n    - The resulting posterior distribution of parameter values will have a posterior probability associated to each value.\n    - Perform a weighted sampling from this posterior distribution.\n*)\n\nlet samplingVsGridApproximationFig = \n    let nTrials = 3\n    let nSuccesses = 3\n    let probas = Generate.LinearSpaced(1000, 0., 1.)\n    let prior = [|for _ in 0. .. ((float probas.Length) - 1.) -\u003E 1.|]\n    let likelihood = [|for p in probas -\u003E Binomial.PMF(p=p, n=nTrials, k=nSuccesses)|]\n    let posterior = rethinking.computePosterior likelihood prior\n\n    [100; 1000; 10000; 100000]\n    |\u003E List.map (fun xs -\u003E \n        np.random.choice(a=toNDarray probas, size=[|xs|], p=toNDarray posterior) \n        |\u003E toSharp\n        |\u003E fun xs -\u003E\n            let traceName = $\u0022# Samples: {xs.Length}\u0022\n            Chart.Histogram(xs, Name=traceName))\n    |\u003E Chart.combine\n    |\u003E Chart.withXAxisStyle(\u0022Proportion of water (parameter p)\u0022, MinMax=(0., 1.))\n    |\u003E Chart.withYAxisStyle(\u0022Counts\u0022)\n    |\u003E fun samplingFig -\u003E\n        [samplingFig; \n         rethinking.binomialMultiGridApproximationFig (fun x -\u003E 1.) [probas.Length] nTrials nSuccesses]\n        |\u003E Chart.Grid(2, 1)\n        |\u003E Chart.withSize(1500, 750)\n        |\u003E Chart.withTitle($\u0022Binomial Distribution (nTrials: {nTrials}, nSucesses: {nSuccesses})\u0022)\n\n(**\n\u0022All you have done so far is crudely replicate the posterior density you had already computed. That isn\u0027t of much value.\u0022\n\n1. Intervals of defined boundaries\n2. Intervals of defined probability mass\n3. Point estimates\n*)\n\n// Intervals of defined boundaries\nlet probabilityMass parameterValues probabilities lowerBound upperBound : float = \n    Seq.zip parameterValues probabilities\n    |\u003E Seq.sumBy (fun (param, proba) -\u003E \n        if param \u003E lowerBound \u0026\u0026 param \u003C upperBound \n        then proba else 0.)\n\nlet probabilityMassByCounts parameterValues lowerBound upperBound : float = \n    let x = 1. / float (Seq.length parameterValues)\n    parameterValues\n    |\u003E Seq.sumBy (fun param -\u003E \n        if param \u003E lowerBound \u0026\u0026 param \u003C upperBound\n        then x else 0.)\n\n// Intervals of defined mass\nlet percentileInterval q data : float * float = \n    let tailMass = (1. - q) / 2.\n    [|tailMass; 1. - tailMass|]\n    |\u003E Array.map (fun q -\u003E Quantile.normal q data)\n    |\u003E fun xs -\u003E xs.[0], xs.[1]\n\nlet formatNumb (x : float) = Math.Round(x, 2).ToString(\u00220.00\u0022)\n\nlet intervalFig parameterGrid probabilities bounds =\n    let computeProbaMassByBounds lowerBound upperBound = probabilityMass parameterGrid probabilities lowerBound upperBound\n    \n    let name = \n        $\u0022\u0022\u0022Interval: [{bounds |\u003E fst |\u003E formatNumb} - {bounds |\u003E snd |\u003E formatNumb}]\u0022\u0022\u0022 \u002B \n        $\u0022 Probability mass:\u0022 \u002B\n        $\u0022\u0022\u0022 [ L: {computeProbaMassByBounds (parameterGrid |\u003E Seq.min) (bounds |\u003E fst) |\u003E formatNumb}\u0022\u0022\u0022 \u002B\n        $\u0022\u0022\u0022 | C: {computeProbaMassByBounds (bounds |\u003E fst) (bounds |\u003E snd) |\u003E formatNumb}\u0022\u0022\u0022 \u002B\n        $\u0022\u0022\u0022 | R: {computeProbaMassByBounds (bounds |\u003E snd) (parameterGrid |\u003E Seq.max) |\u003E formatNumb}]\u0022\u0022\u0022\n    \n    let xy = Array.zip parameterGrid probabilities\n    [\n        xy\n        |\u003E Array.filter (fun (param, proba) -\u003E param \u003E= fst bounds \u0026\u0026 param \u003C= snd bounds)\n        |\u003E Array.unzip\n        |\u003E fun (x, y) -\u003E Chart.SplineArea(x, y, Name=name, MarkerColor=Color.fromString(\u0022purple\u0022));\n\n        Chart.Line(xy, ShowLegend=false, MarkerColor=Color.fromString(\u0022purple\u0022))\n    ]\n    |\u003E Chart.combine\n    |\u003E Chart.withTitle(\u0022Interval comparison\u0022)\n    |\u003E Chart.withXAxisStyle(\u0022Proportion of water (parameter p)\u0022, MinMax=(0., 1.))\n    |\u003E Chart.withYAxisStyle(\u0022Posterior probability\u0022)\n\nlet nTrials = 3\nlet nSuccesses = 3\nlet paramGrid = Generate.LinearSpaced(1000, 0., 1.)\nlet prior = [|for _ in 0. .. ((float paramGrid.Length) - 1.) -\u003E 1.|]\nlet likelihood = [|for p in paramGrid -\u003E Binomial.PMF(p=p, n=nTrials, k=nSuccesses)|]\nlet posterior = rethinking.computePosterior likelihood prior\nlet samples = np.random.choice(a=toNDarray paramGrid, size=[|1000000|], replace=true, p=toNDarray posterior) |\u003E toSharp\n\nlet intervalComparisonFig = \n    [\n        intervalFig paramGrid posterior (0., 0.5); \n        intervalFig paramGrid posterior (0.5, 0.75);\n        intervalFig paramGrid posterior (0., Quantile.normal 0.8 samples);\n        intervalFig paramGrid posterior (percentileInterval 0.8 samples)\n    ]\n    |\u003E Chart.Grid(2, 2)\n    |\u003E Chart.withSize(1500, 800)\n\n(**\nHPDI - Highest Posterior Desity Interval\n*)\n\n(**\nPoint estimates\n\nGiven the entire posterior distribution, what value should you report?\n\n*Maximum a posteriori* (MAP) estimate.\n-\u003E The mode of the posterior distribution\n*)\n\nlet modeFromGridEstimate = \n    Seq.zip paramGrid posterior\n    |\u003E Seq.sortByDescending snd\n    |\u003E Seq.head\n    |\u003E fst\n\nlet computeMode x = \n    x\n    |\u003E Seq.groupBy id\n    |\u003E Seq.map (fun (paramValue, xs) -\u003E (paramValue, Seq.length xs))\n    |\u003E Seq.sortByDescending snd\n    |\u003E Seq.head\n    |\u003E fst\n\nlet pointEstimatesPlot paramGrid posterior = \n    let initXAxisLine x = \n        Shape.init (StyleParam.ShapeType.Line, X0 = x, X1 = x, Y0 = 0, Y1 = 1, Xref = \u0022x\u0022, Yref = \u0022paper\u0022, Line = Line.init (Width = 1.5))\n\n    let initAnnotation x text =\n        Annotation.init (X = x - (x * 0.025), Y = 0.15, Text = text, XRef = \u0022x\u0022, YRef = \u0022paper\u0022, ShowArrow = false, TextAngle = 270.)\n\n    let mean, median, mode = \n        let samples = \n            np.random.choice(a=toNDarray paramGrid, size=[|1000000|], replace=true, p=toNDarray posterior) \n            |\u003E toSharp\n        \n        Seq.average samples,\n        Seq.median samples,\n        computeMode samples\n\n    let chartName = $\u0022Posterior Probabilities (Mean: {formatNumb mean} ; Median: {formatNumb median} ; Mode: {formatNumb mode})\u0022\n\n    Chart.Line(Array.zip paramGrid posterior, Name=chartName)\n    |\u003E Chart.withAnnotations ([ initAnnotation mean \u0022mean\u0022; initAnnotation median \u0022median\u0022; initAnnotation mode \u0022mode\u0022])\n    |\u003E Chart.withShapes([initXAxisLine mean; initXAxisLine median; initXAxisLine mode])\n    |\u003E Chart.withXAxisStyle(\u0022Proportion of water (parameter p)\u0022)\n    |\u003E Chart.withYAxisStyle(\u0022Posterior probabilities\u0022)\n    |\u003E Chart.withSize(600., 500.)\n\n// Loss functions\n// Loss functions imply different point estimates\n\ntype LossFunc = \n    | ApproximateZeroOne \n    | ZeroOne\n    | Absolute\n    | Quadratic\n    override this.ToString() = \n        match this with\n        | ApproximateZeroOne -\u003E \u0022Approximate Zero One Loss\u0022\n        | ZeroOne -\u003E \u0022L0 - Zero One Loss\u0022\n        | Absolute -\u003E \u0022L1 - Absolute Loss\u0022\n        | Quadratic -\u003E \u0022L2 - Quadratic Loss\u0022\n\nlet pickLossError lossError theta theta\u0027 : float = \n    match lossError with\n    | ApproximateZeroOne -\u003E if theta - theta\u0027 \u003C 1e-16 then 0. else 1.\n    | ZeroOne -\u003E if theta.Equals(theta\u0027) then 0. else 1.\n    | Absolute -\u003E (theta - theta\u0027) |\u003E abs\n    | Quadratic -\u003E (theta - theta\u0027) ** 2.\n\nlet expectedLoss lossFunc (paramGuess : float) (paramGrid : float array) posterior : float =\n    Array.zip paramGrid posterior\n    |\u003E Array.sumBy (fun (trueParam, posteriorProba) -\u003E posteriorProba * lossFunc trueParam paramGuess)\n\nlet lossFuncFig lossError paramGrid posterior = \n    let lossFuncXy = \n        Generate.LinearSpaced(10000, 0., 1.)\n        |\u003E Array.map( fun xs -\u003E (xs, expectedLoss (pickLossError lossError) xs paramGrid posterior))\n    \n    let minX, minY = \n        lossFuncXy \n        |\u003E Array.minBy snd\n\n    let minXYString =\n        $\u0022Minimum: ({formatNumb minX} ; {formatNumb minY})\u0022\n\n    [Chart.Line(lossFuncXy, Name=lossError.ToString()); Chart.Point([|(minX, minY)|], Name=minXYString, MarkerSymbol=StyleParam.MarkerSymbol.StarDiamond)\n    ]\n    |\u003E Chart.combine\n    |\u003E Chart.withXAxisStyle(\u0022Proportion of water (parameter p)\u0022)\n    |\u003E Chart.withYAxisStyle(\u0022Loss\u0022)\n\nlet pointEstimateAndlossFuncComparisonFig = \n    let chartTitle = $\u0022Point estimates and Loss functions (n = {Seq.length paramGrid}; Grid Aprroximation)\u0022\n    [\n        pointEstimatesPlot paramGrid posterior;\n        lossFuncFig LossFunc.ZeroOne paramGrid posterior;\n        [\n            lossFuncFig LossFunc.ApproximateZeroOne paramGrid posterior;\n            lossFuncFig LossFunc.Absolute paramGrid posterior; \n            lossFuncFig LossFunc.Quadratic paramGrid posterior\n        ]\n        |\u003E Chart.combine\n\n    ]\n    |\u003E Chart.Grid(1, 3)\n    |\u003E Chart.withSize(1800., 500.)\n    |\u003E Chart.withTitle(chartTitle)\n\n(**\nSampling to simulate prediction\n*)\n"},{"uri":"http://localhost:8901/Scripts/Common.html","title":"Common","content":"(**\n---\ntitle: Common\ncategory: Scripts\ncategoryindex: 1\nindex: 1\n---\n*)\n\nnamespace Common\n\n#r \u0022nuget: FSharp.Stats, 0.4.6\u0022\n#r \u0022nuget: Numpy, 3.10.1.29\u0022\n#r \u0022nuget: Plotly.NET, 3.0.0\u0022\n#r \u0022nuget: Plotly.NET.Interactive, 3.0.0\u0022\n\nopen System\nopen Numpy\nopen Plotly.NET\nopen FSharp.Stats.Distributions\n\nmodule rethinking = \n    let private r = System.Random(0)\n\n    let computePosterior likelihood prior : array\u003Cfloat\u003E = \n        prior\n        |\u003E Array.zip likelihood\n        |\u003E Array.map (fun (likelihood_i, prior_i) -\u003E likelihood_i * prior_i)\n        |\u003E fun unstandardizedPosterior -\u003E \n            let sum = Array.sum unstandardizedPosterior\n            unstandardizedPosterior |\u003E Array.map (fun xs -\u003E xs / sum)\n    \n    let binomialMultiGridApproximationFig priorFunc (points : list\u003Cint\u003E) (nTrials : int) (nSucesses : int)= \n        points\n        |\u003E List.map (fun nPointsToEstimate -\u003E \n            let probas = [|0. .. (1. / (float nPointsToEstimate - 1.)) .. \n                if nTrials \u003C\u003E nSucesses then 1. \n                else 0.999999999999999|]\n\n            let prior, likelihood = \n                probas \n                |\u003E Array.map (fun p -\u003E \n                    priorFunc p, (Discrete.binomial p nTrials).PDF nSucesses)\n                |\u003E Array.unzip\n            \n            Chart.Line(probas, computePosterior likelihood prior, Name = $\u0022# Grid Points: {probas.Length}\u0022))\n        |\u003E Chart.combine\n        |\u003E Chart.withTitle(\u0022Grid approximate posterior distribution\u0022)\n        |\u003E Chart.withXAxisStyle(\u0022Proportion of water (parameter p)\u0022, MinMax=(0., 1.))\n        |\u003E Chart.withYAxisStyle(\u0022Posterior probability\u0022)\n        |\u003E Chart.withSize(650., 650.)\n\nmodule NumpyUtils = \n    let toNDarray (xs : seq\u003C_\u003E) : NDarray = \n        np.asarray\u003C_\u003E(Seq.toArray xs)\n\n    let toSharp (xs : NDarray) : array\u003Cfloat\u003E = \n        xs.astype(np.float_).GetData\u003Cfloat\u003E()"}]