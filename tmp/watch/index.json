[{"uri":"http://localhost:8901/Ch03.html","title":"Chapter 3","content":"(**\n---\ntitle: Chapter 3\ncategory: Scripts\ncategoryindex: 1\nindex: 3\n---\n*)\n\n#load \u0022Common.fsx\u0022\n#r \u0022nuget: FSharp.Stats, 0.4.7\u0022\n#r \u0022nuget: Plotly.NET, 3.0.0\u0022\n#r \u0022nuget: Plotly.NET.Interactive, 3.0.0\u0022\n#r \u0022nuget: Numpy, 3.10.1.29\u0022\n#r \u0022nuget: MathNet.Numerics, 5.0.0\u0022\n\nopen System\nopen FSharp.Stats\nopen Numpy\nopen Plotly.NET\nopen Plotly.NET.Interactive\nopen Plotly.NET.LayoutObjects\nopen MathNet.Numerics\nopen MathNet.Numerics.Distributions\n\nEnvironment.CurrentDirectory \u003C- __SOURCE_DIRECTORY__\nopen Common\nopen Common.GridApproximation\nopen Common.NumpyUtils\n\n(**\n**Reconstructing the posterior distribution via sampling.**\n\n**Estimate posterior distribution with the Grid Approximation method**\n    - Choose n points to estimate\n    - Compute the likelihoods over a range of probabilities (parameter values) (binomial distribution)\n    - Adjust for the given prior (uniform, heavyside, etc ...)\n    - Standardize\n    - The resulting posterior distribution of parameter values will have a posterior probability associated to each value.\n    - Perform a weighted sampling from this posterior distribution.\n*)\n\nlet samplingVsGridApproximationFig = \n    let nTrials = 3\n    let nSuccesses = 3\n    let probas = Generate.LinearSpaced(1000, 0., 1.)\n    let prior = [|for _ in 0. .. ((float probas.Length) - 1.) -\u003E 1.|]\n    let likelihood = [|for p in probas -\u003E Binomial.PMF(p=p, n=nTrials, k=nSuccesses)|]\n    let posterior = GridApproximation.posteriorProbabilities likelihood prior\n\n    [100; 1000; 10000; 100000]\n    |\u003E List.map (fun xs -\u003E \n        np.random.choice(a=toNDarray probas, size=[|xs|], p=toNDarray posterior) \n        |\u003E toSharp\n        |\u003E fun xs -\u003E\n            let traceName = $\u0022# Samples: {xs.Length}\u0022\n            Chart.Histogram(xs, Name=traceName))\n    |\u003E Chart.combine\n    |\u003E Chart.withXAxisStyle(\u0022Proportion of water (parameter p)\u0022, MinMax=(0., 1.))\n    |\u003E Chart.withYAxisStyle(\u0022Counts\u0022)\n    |\u003E fun samplingFig -\u003E\n        [samplingFig; \n         GridApproximation.multiBinominalPosteriorFig (fun x -\u003E 1.) [probas.Length] nTrials nSuccesses]\n        |\u003E Chart.Grid(2, 1)\n        |\u003E Chart.withSize(1500, 750)\n        |\u003E Chart.withTitle($\u0022Binomial Distribution (nTrials: {nTrials}, nSucesses: {nSuccesses})\u0022)\n\n(**\n\u0022All you have done so far is crudely replicate the posterior density you had already computed. That isn\u0027t of much value.\u0022\n\n1. Intervals of defined boundaries\n2. Intervals of defined probability mass\n3. Point estimates\n*)\n\n// Intervals of defined boundaries\nlet probabilityMass parameterValues probabilities lowerBound upperBound : float = \n    Seq.zip parameterValues probabilities\n    |\u003E Seq.sumBy (fun (param, proba) -\u003E \n        if param \u003E lowerBound \u0026\u0026 param \u003C upperBound \n        then proba else 0.)\n\nlet probabilityMassByCounts parameterValues lowerBound upperBound : float = \n    let x = 1. / float (Seq.length parameterValues)\n    parameterValues\n    |\u003E Seq.sumBy (fun param -\u003E \n        if param \u003E lowerBound \u0026\u0026 param \u003C upperBound\n        then x else 0.)\n\n// Intervals of defined mass\nlet percentileInterval q data : float * float = \n    let tailMass = (1. - q) / 2.\n    [|tailMass; 1. - tailMass|]\n    |\u003E Array.map (fun q -\u003E Quantile.normal q data)\n    |\u003E fun xs -\u003E xs.[0], xs.[1]\n\nlet formatNumb (x : float) = Math.Round(x, 2).ToString(\u00220.00\u0022)\n\nlet intervalFig parameterGrid probabilities bounds =\n    let computeProbaMassByBounds lowerBound upperBound = probabilityMass parameterGrid probabilities lowerBound upperBound\n    \n    let name = \n        $\u0022\u0022\u0022Interval: [{bounds |\u003E fst |\u003E formatNumb} - {bounds |\u003E snd |\u003E formatNumb}]\u0022\u0022\u0022 \u002B \n        $\u0022 Probability mass:\u0022 \u002B\n        $\u0022\u0022\u0022 [ L: {computeProbaMassByBounds (parameterGrid |\u003E Seq.min) (bounds |\u003E fst) |\u003E formatNumb}\u0022\u0022\u0022 \u002B\n        $\u0022\u0022\u0022 | C: {computeProbaMassByBounds (bounds |\u003E fst) (bounds |\u003E snd) |\u003E formatNumb}\u0022\u0022\u0022 \u002B\n        $\u0022\u0022\u0022 | R: {computeProbaMassByBounds (bounds |\u003E snd) (parameterGrid |\u003E Seq.max) |\u003E formatNumb}]\u0022\u0022\u0022\n    \n    let xy = Array.zip parameterGrid probabilities\n    [\n        xy\n        |\u003E Array.filter (fun (param, proba) -\u003E param \u003E= fst bounds \u0026\u0026 param \u003C= snd bounds)\n        |\u003E Array.unzip\n        |\u003E fun (x, y) -\u003E Chart.SplineArea(x, y, Name=name, MarkerColor=Color.fromString(\u0022purple\u0022));\n\n        Chart.Line(xy, ShowLegend=false, MarkerColor=Color.fromString(\u0022purple\u0022))\n    ]\n    |\u003E Chart.combine\n    |\u003E Chart.withTitle(\u0022Interval comparison\u0022)\n    |\u003E Chart.withXAxisStyle(\u0022Proportion of water (parameter p)\u0022, MinMax=(0., 1.))\n    |\u003E Chart.withYAxisStyle(\u0022Posterior probability\u0022)\n\nlet nTrials = 3\nlet nSuccesses = 3\nlet paramGrid = Generate.LinearSpaced(1000, 0., 1.)\nlet prior = [|for _ in 0. .. ((float paramGrid.Length) - 1.) -\u003E 1.|]\nlet likelihood = [|for p in paramGrid -\u003E Binomial.PMF(p=p, n=nTrials, k=nSuccesses)|]\nlet posterior = GridApproximation.posteriorProbabilities likelihood prior\nlet samples = np.random.choice(a=toNDarray paramGrid, size=[|1000000|], replace=true, p=toNDarray posterior) |\u003E toSharp\n\nlet intervalComparisonFig = \n    [\n        intervalFig paramGrid posterior (0., 0.5); \n        intervalFig paramGrid posterior (0.5, 0.75);\n        intervalFig paramGrid posterior (0., Quantile.normal 0.8 samples);\n        intervalFig paramGrid posterior (percentileInterval 0.8 samples)\n    ]\n    |\u003E Chart.Grid(2, 2)\n    |\u003E Chart.withSize(1500, 800)\n\n(**\nHPDI - Highest Posterior Desity Interval\n*)\n\n(**\nPoint estimates\n\nGiven the entire posterior distribution, what value should you report?\n\n*Maximum a posteriori* (MAP) estimate.\n-\u003E The mode of the posterior distribution\n*)\n\nlet modeFromGridEstimate = \n    Seq.zip paramGrid posterior\n    |\u003E Seq.sortByDescending snd\n    |\u003E Seq.head\n    |\u003E fst\n\nlet computeMode x = \n    x\n    |\u003E Seq.groupBy id\n    |\u003E Seq.map (fun (paramValue, xs) -\u003E (paramValue, Seq.length xs))\n    |\u003E Seq.sortByDescending snd\n    |\u003E Seq.head\n    |\u003E fst\n\nlet pointEstimatesPlot paramGrid posterior = \n    let initXAxisLine x = \n        Shape.init (StyleParam.ShapeType.Line, X0 = x, X1 = x, Y0 = 0, Y1 = 1, Xref = \u0022x\u0022, Yref = \u0022paper\u0022, Line = Line.init (Width = 1.5))\n\n    let initAnnotation x text =\n        Annotation.init (X = x - (x * 0.025), Y = 0.15, Text = text, XRef = \u0022x\u0022, YRef = \u0022paper\u0022, ShowArrow = false, TextAngle = 270.)\n\n    let mean, median, mode = \n        let samples = \n            np.random.choice(a=toNDarray paramGrid, size=[|1000000|], replace=true, p=toNDarray posterior) \n            |\u003E toSharp\n        \n        Seq.average samples,\n        Seq.median samples,\n        computeMode samples\n\n    let chartName = $\u0022Posterior Probabilities (Mean: {formatNumb mean} ; Median: {formatNumb median} ; Mode: {formatNumb mode})\u0022\n\n    Chart.Line(Array.zip paramGrid posterior, Name=chartName)\n    |\u003E Chart.withAnnotations ([ initAnnotation mean \u0022mean\u0022; initAnnotation median \u0022median\u0022; initAnnotation mode \u0022mode\u0022])\n    |\u003E Chart.withShapes([initXAxisLine mean; initXAxisLine median; initXAxisLine mode])\n    |\u003E Chart.withXAxisStyle(\u0022Proportion of water (parameter p)\u0022)\n    |\u003E Chart.withYAxisStyle(\u0022Posterior probabilities\u0022)\n    |\u003E Chart.withSize(600., 500.)\n\n// Loss functions\n// Loss functions imply different point estimates\n\ntype LossFunc = \n    | ApproximateZeroOne \n    | ZeroOne\n    | Absolute\n    | Quadratic\n    override this.ToString() = \n        match this with\n        | ApproximateZeroOne -\u003E \u0022Approximate Zero One Loss\u0022\n        | ZeroOne -\u003E \u0022L0 - Zero One Loss\u0022\n        | Absolute -\u003E \u0022L1 - Absolute Loss\u0022\n        | Quadratic -\u003E \u0022L2 - Quadratic Loss\u0022\n\nlet pickLossError lossError theta theta\u0027 : float = \n    match lossError with\n    | ApproximateZeroOne -\u003E if theta - theta\u0027 \u003C 1e-16 then 0. else 1.\n    | ZeroOne -\u003E if theta.Equals(theta\u0027) then 0. else 1.\n    | Absolute -\u003E (theta - theta\u0027) |\u003E abs\n    | Quadratic -\u003E (theta - theta\u0027) ** 2.\n\nlet expectedLoss lossFunc (paramGuess : float) (paramGrid : float array) posterior : float =\n    Array.zip paramGrid posterior\n    |\u003E Array.sumBy (fun (trueParam, posteriorProba) -\u003E posteriorProba * lossFunc trueParam paramGuess)\n\nlet lossFuncFig lossError paramGrid posterior = \n    let lossFuncXy = \n        Generate.LinearSpaced(10000, 0., 1.)\n        |\u003E Array.map( fun xs -\u003E (xs, expectedLoss (pickLossError lossError) xs paramGrid posterior))\n    \n    let minX, minY = \n        lossFuncXy \n        |\u003E Array.minBy snd\n\n    let minXYString =\n        $\u0022Minimum: ({formatNumb minX} ; {formatNumb minY})\u0022\n\n    [Chart.Line(lossFuncXy, Name=lossError.ToString()); Chart.Point([|(minX, minY)|], Name=minXYString, MarkerSymbol=StyleParam.MarkerSymbol.StarDiamond)\n    ]\n    |\u003E Chart.combine\n    |\u003E Chart.withXAxisStyle(\u0022Proportion of water (parameter p)\u0022)\n    |\u003E Chart.withYAxisStyle(\u0022Loss\u0022)\n\nlet pointEstimateAndlossFuncComparisonFig = \n    let chartTitle = $\u0022Point estimates and Loss functions (n = {Seq.length paramGrid}; Grid Aprroximation)\u0022\n    [\n        pointEstimatesPlot paramGrid posterior;\n        lossFuncFig LossFunc.ZeroOne paramGrid posterior;\n        [\n            lossFuncFig LossFunc.ApproximateZeroOne paramGrid posterior;\n            lossFuncFig LossFunc.Absolute paramGrid posterior; \n            lossFuncFig LossFunc.Quadratic paramGrid posterior\n        ]\n        |\u003E Chart.combine\n\n    ]\n    |\u003E Chart.Grid(1, 3)\n    |\u003E Chart.withSize(1800., 500.)\n    |\u003E Chart.withTitle(chartTitle)\n    |\u003E GenericChart.toChartHTML\n\npointEstimateAndlossFuncComparisonFig\n(*** include-it-raw ***)\n(**\nSampling to simulate prediction\n*)"},{"uri":"http://localhost:8901/Ch02.html","title":"Chapter 2: Small Worlds and Large Worlds","content":"(**\n---\ntitle: Chapter 2: Small Worlds and Large Worlds\ncategory: Practice\ncategoryindex: 1\nindex: 2\n---\n*)\n\nopen System\nopen System.IO\nEnvironment.CurrentDirectory \u003C- __SOURCE_DIRECTORY__\n\n(**\n### NuGet packages\n*)\n\n#r \u0022nuget: Plotly.NET, 3.0.0\u0022\n#r \u0022nuget: Plotly.NET.Interactive, 3.0.2\u0022\n#r \u0022nuget: MathNet.Numerics, 5.0.0\u0022\n\nopen Plotly.NET\nopen Plotly.NET.Interactive\nopen MathNet.Numerics\nopen MathNet.Numerics.Distributions\n\n(**\n### Scripts\n*)\n\n#load \u0022Common.fsx\u0022\n\nopen Common\nopen Common.GridApproximation\n\n(**\n# Practice\n\nProblems are labeled Easy(E), Medium(M), and Hard(H).\n*)\n\n(**\n**2E1.** Which of the expressions below correspond to the statement: *the probability of rain on Monday* ?\n\n(4) $Pr(rain|Monday)$\n*)\n\n(**\n2E2. Which of the following statements corresponds to the expression: $Pr(rain|Monday)$ ?\n\n(3) The probability of rain, given that it is Monday.\n*)\n\n(**\n2E3. Pr(Monday|rain); Pr(rain|Monday)Pr(Monday) / Pr(rain)\n*)\n\n(**\n2E4. \u0022the probability of water is 0.7\u0022 -\u003E Here, 0.7 represents the proportion of the globe that is covered in water.\n*)\n\n(**\nMedium\n*)\n\n(**\n### **2M1**. \n### Recall the globe tossing model from the chapter. Compute and plot the grid approximate posterior distribution for each of the following sets of observations. In each case, assume a uniform prior for p.\n\nFor the globe tossing model, let the random variable $X$ represent the number of times you observe *water* when tossing the globe.\n It is given that the true proportion of water covering the globe is $p$, and so the probability of observing *water* (W) on each single independent \n toss is also $p$. Conversely, the probability or true proportion of *land* (L) covering the globe is $q = (1 - p)$.\n\nThe probability of getting exactly $k$ successes in $n$ independent Bernoulli trials is given by the probability mass function (PMF):\n\n$$f(k,n,p)=Pr(k;n,p)=Pr(X=k)={n \\choose k}p^{k}q^{n-k} \\text{ , for } k = 0, 1, 2,  \\ldots, n$$\n\n$$n \\in \\mathbb{N} \\text{ , } p \\in [0,1]$$\n\nHere, ${n \\choose k} = \\frac{n!}{k!(n-k)!}$, represents the number of ways \u0022$k$ successes\u0022 can happen out of \u0022$n$ trials.\u0022\n\nFor example, in the globe tossing model, if we consider $n=3$ and $k=1$:\n\nPossible outcomes or paths: \n\n$\\{ LLL, \\boldsymbol{LLW}, \\boldsymbol{LWL} , \\boldsymbol{WLL}, WWL , WLW, LWW, WWW \\}$\n\nEquivalently, \n\n$\\binom{n}{k} = \\frac{3!}{1! \\times (3 - 1)!} = 3$\n\nFor each possible path, we have to account for the respective probabilities $p$ and $q$. \n Since each Bernoulli trial is independent we can simply multiply the probabilities $p$ and $q$ to obtain the probability of a successful path ($X=k$).\n In our example, the probability of observing every such path is $p \\cdot p \\cdot q$ or simply $p^{2} \\cdot q$. \n And so $P(X=1)$ is the sum of the probabilities of all paths with exactly $1$ successes:\n \n$P(\\boldsymbol{LLW})=P(\\boldsymbol{LWL})=P(\\boldsymbol{WLL})=p^{1}q^{2}$\n\n$P(X=1)=P(\\boldsymbol{LLW}) \u002B P(\\boldsymbol{LWL}) \u002B P(\\boldsymbol{WLL})=3\\times p^{1}q^{2}$\n\n*)\n\nlet binomialBreakdownFig priorFunc nTrials nSucesses = \n    let title = sprintf  @\u0022\u0022\u0022$ \\text{ Binomial distribution - } (n=%i,\\: k=%i) $\u0022\u0022\u0022 nTrials nSucesses\n    let paramGrid = Generate.LinearSpaced(10000, 0., 1.)\n    let prior = paramGrid |\u003E Array.map priorFunc\n    let likelihood = paramGrid |\u003E Array.map (fun xs -\u003E Binomial.PMF(p=xs, n=nTrials, k=nSucesses))\n\n    [\n        Chart.Line(paramGrid, prior, LineDash=StyleParam.DrawingStyle.Dot, Name=\u0022Prior\u0022)\n        |\u003E Chart.withYAxisStyle(\u0022Probability\u0022)\n        \n        Chart.Line(paramGrid, likelihood, LineDash=StyleParam.DrawingStyle.Dot, Name=\u0022Likelihood\u0022)\n        |\u003E Chart.withYAxisStyle(\u0022Probability\u0022)\n\n        Chart.Line(paramGrid, posteriorProbabilities prior likelihood, Name=\u0022Posterior\u0022)\n        |\u003E Chart.withYAxisStyle(\u0022Probability\u0022)\n\n    ]\n    |\u003E Chart.SingleStack(Pattern= StyleParam.LayoutGridPattern.Coupled)\n    |\u003E Chart.withLayoutGridStyle(YGap= 0.1)\n    |\u003E Chart.withXAxisStyle(\u0022\u0022\u0022$ \\text{ Parameter } p$\u0022\u0022\u0022)\n    |\u003E Chart.withTitle(title)\n    |\u003E Chart.withSize(1000, 600)\n    |\u003E Chart.withMathTex(true)\n\n(**\n### **2M1.** \n### Uniform Prior | N=3, W=3, L=0\n*)\n(***do-not-eval***)\nbinomialBreakdownFig (fun x -\u003E 1.) 3 3 |\u003E Chart.show\n(***hide***)\nbinomialBreakdownFig (fun x -\u003E 1.) 3 3\n|\u003E GenericChart.toChartHTML\n(*** include-it-raw ***)\n\n(**\n### **2M1.** \n### Uniform Prior | N=4, W=3, L=1\n*)\n(***do-not-eval***)\nbinomialBreakdownFig (fun x -\u003E 1.) 4 3 |\u003E Chart.show\n(***hide***)\nbinomialBreakdownFig (fun x -\u003E 1.) 4 3\n|\u003E GenericChart.toChartHTML\n(*** include-it-raw ***)\n\n(**\n### **2M1.** \n### Uniform Prior | N=7, W=5, L=2\n*)\n(***do-not-eval***)\nbinomialBreakdownFig (fun x -\u003E 1.) 7 5 |\u003E Chart.show\n(***hide***)\nbinomialBreakdownFig (fun x -\u003E 1.) 7 5\n|\u003E GenericChart.toChartHTML\n(*** include-it-raw ***)\n\n(**\n### **2M2**. \n### Now assume a prior for $p$ that is equal to zero when $p \u003C 0.5$ and is a positive constant when p \u003E 0.5 . Again compute and plot the grid approximate posterior distribution for each of the sets of observations in the problem just above.\n*)\n\n(**\n### **2M2.** \n### Heavyside step function Prior | N=3, W=3, L=0\n*)\n(***do-not-eval***)\nbinomialBreakdownFig (fun x -\u003E if x \u003C 0.5 then 0. else 1.) 3 3\n(***hide***)\nbinomialBreakdownFig (fun x -\u003E if x \u003C 0.5 then 0. else 1.) 3 3\n|\u003E GenericChart.toChartHTML\n(*** include-it-raw ***)\n\n(**\n### **2M2.** \n### Heavyside step function Posterior | N=4, W=3, L=1\n*)\n(***do-not-eval***)\nbinomialBreakdownFig (fun x -\u003E if x \u003C 0.5 then 0. else 1.) 4 3\n(***hide***)\nbinomialBreakdownFig (fun x -\u003E if x \u003C 0.5 then 0. else 1.) 4 3\n|\u003E GenericChart.toChartHTML\n(*** include-it-raw ***)\n\n(**\n### **2M2.** \n### Heavyside step function Prior | N=7, W=5, L=2\n*)\n(***do-not-eval***)\nbinomialBreakdownFig (fun x -\u003E if x \u003C 0.5 then 0. else 1.) 7 5\n(***hide***)\nbinomialBreakdownFig (fun x -\u003E if x \u003C 0.5 then 0. else 1.) 7 5\n|\u003E GenericChart.toChartHTML\n(*** include-it-raw ***)\n\n(**\nComputing the posterior distribution by grid approximation comes with its caveats. \nAs shown below, the approximation will get closer to the analytically solved version of the posterior distribution.\n*)\n\nlet multiBinominalPosteriorFig priorFunc points nTrials nSuccesses = \n    let title = sprintf @\u0022\u0022\u0022$ \\text{Grid approximation - Posterior Distribution } (n=%i, k=%i)$\u0022 nTrials nSuccesses\n    points\n    |\u003E Seq.map (fun xs -\u003E \n        let probas = Generate.LinearSpaced(xs, 0., 1.)\n        let prior = probas|\u003E Array.map priorFunc\n        Chart.Line(probas, binomialPosterior prior nTrials nSuccesses, Name = $\u0022# Grid Points: {probas.Length}\u0022))\n    |\u003E Chart.combine\n    |\u003E Chart.withTitle(title)\n    |\u003E Chart.withXAxisStyle(@\u0022$ \\text{Parameter } p$\u0022)\n    |\u003E Chart.withYAxisStyle(\u0022Posterior probability\u0022)\n    |\u003E Chart.withSize(1000, 500)\n\n(***do-not-eval***)\nmultiBinominalPosteriorFig (fun x -\u003E 1.) [10 .. 10 .. 100] 10 1\n(***hide***)\nmultiBinominalPosteriorFig (fun x -\u003E 1.) [10 .. 10 .. 100] 10 1\n|\u003E GenericChart.toChartHTML\n(*** include-it-raw ***)\n\n(**\n### **2M3.** \n### Suppose there are two globes, one for Earth and one for Mars. The Earth globe is 70% covered in water. The Mars globe is 100% land. Further suppose that one of these globes\u2014you don\u2019t know which\u2014was tossed in the air and produced a \u201Cland\u201D observation. Assume that each globe was equally likely to be tossed. Show that the posterior probability that the globe was the Earth, conditional on seeing \u201Cland\u201D $Pr(Earth|Land) = 0.23$.\n*)\n\n(**\n\n$\\Pr(Earth \\mid Land) = \\frac{\\Pr(Land \\mid Earth) \\times \\Pr(Earth)}{\\Pr(Land)} = \\frac{\\Pr(Land \\mid Earth) \\times \\Pr(Earth)}{(\\Pr(Earth) \\times \\Pr(Land \\mid Earth)) \u002B (\\Pr(Mars) \\times \\Pr(Land \\mid Mars))}$\n\n*)\n\nlet formatNumb (x: float) = Math.Round(x, 2)\n\nlet prLandGivenEarth = 0.3\nlet prLandGivenMars = 1.\nlet prEarth = 0.5\nlet prMars = 0.5\nlet prLand = ((prMars * prLandGivenMars) \u002B (prEarth * prLandGivenEarth))\n\n(prLandGivenEarth * prEarth) / prLand\n|\u003E formatNumb\n(*** include-it-raw ***)\n\n(**\n### **2M4.** \n### Suppose you have a deck with only three cards. Each card has two sides, and each side is either black or white. One card has two black sides. The second card has one black and one white side. The third card has two white sides. Now suppose all three cards are placed in a bag and shuffled. Someone reaches into the bag and pulls out a card and places it flat on a table. A black side is shown facing up, but you don\u2019t know the color of the side facing down. Show that the probability that the other side is also black is 2/3. Use the counting method (Section 2 of the chapter) to approach this problem. This means counting up the ways that each card could produce the observed data (a black side facing up on the table).\n\n3 Cards, 6 Conjectures:\n\n$\\blacksquare: (S_{1}=B, S_{2}=B), (S_{1}=B, S_{2}=B)$\n\n$\\bullet: (S_{1}=B, S_{2}=W), (S_{1}=W, S_{2}=B)$\n\n$\\blacktriangle: (S_{1}=W, S_{2}=W) (S_{1}=W, S_{2}=W)$\n\n # Ways B can appear as the side facing up: 3\n\n # Ways B can appear as the side facing down: 2\n\n$\\Pr(\\blacksquare \\mid S_{1}=B) = \\frac{2}{3}$\n\nUsing Bayes theorem:\n\n$\\Pr(\\blacksquare \\mid S_{1}=B) = \\frac{\\Pr(S_{1}=B \\mid \\blacksquare) \\times \\Pr(\\blacksquare)}{\\Pr(S_{1}=B)} = \\frac{1 \\times \\frac{1}{3}}{\\frac{1}{2}} = \\frac{2}{3}$\n*)\n\n(**\n### **2M5.**\n### Now suppose there are four cards: B/B, B/W, W/W, and another B/B. Again suppose a card is drawn from the bag and a black side appears face up. Again calculate the probability that the other side is black.\n\n4th card: $\\blacksquare$\n\n # Ways B can appear as the side facing up: 3 \u002B 2 = 5\n\n # Ways B can appear as the side facing down: 2 \u002B 2 = 4\n\n$\\Pr(\\blacksquare \\mid S_{1}=B) = \\frac{4}{5}$\n\n$\\Pr(\\blacksquare \\mid S_{1}=B) = \\frac{\\Pr(S_{1}=B \\mid \\blacksquare) \\times \\Pr(\\blacksquare)}{\\Pr(S_{1}=B)} = \\frac{1 \\times \\frac{2}{4}}{\\frac{5}{8}} = \\frac{2}{3}$\n\n*)\n\n(**\n### **2M6.**\n### Imagine that black ink is heavy, and so cards with black sides are heavier than cards with white sides. As a result, it\u2019s less likely that a card with black sides is pulled from the bag. So again assume there are three cards: B/B, B/W, and W/W. After experimenting a number of times, you conclude that for every way to pull the B/B card from the bag, there are 2 ways to pull the B/W card and 3 ways to pull the W/W card. Again suppose that a card is pulled and a black side appears face up. Show that the probability the other side is black is now 0.5. Use the counting method, as before.\n\n # Ways B can appear as the side facing up: 1 ($\\bullet$) \u002B 2 ($\\square$) -\u003E ***2*** ($\\bullet$) \u002B 2 ($\\square$) = 4\n\n # Ways B can appear as the side facing down: 2 ($\\square$) = 2\n\n$\\Pr(\\blacksquare \\mid S_{1}=B) = \\frac{2}{4} = \\frac{1}{2}$\n\n*)\n\n(**\nAdditional sources - \n\n1. https://en.wikipedia.org/wiki/Binomial_distribution\n2. https://www3.nd.edu/~dgalvin1/10120/10120_S16/Topic19_8p6_Galvin.pdf\n*)\n\n\nlet initTheta = 0.5"},{"uri":"http://localhost:8901/index.html","title":"index","content":"Test"},{"uri":"http://localhost:8901/Common.html","title":"Common","content":"(**\n---\ntitle: Common\ncategory: Scripts\ncategoryindex: 1\nindex: 1\n---\n*)\n\nnamespace Common\n\n#r \u0022nuget: Plotly.NET, 3.0.0\u0022\n#r \u0022nuget: Plotly.NET.Interactive, 3.0.0\u0022\n#r \u0022nuget: Numpy, 3.10.1.29\u0022\n#r \u0022nuget: MathNet.Numerics, 5.0.0\u0022\n\nopen Numpy\nopen Plotly.NET\nopen MathNet.Numerics\nopen MathNet.Numerics.Distributions\n\nmodule GridApproximation = \n    let posteriorProbabilities prior likelihood : array\u003Cfloat\u003E = \n        let unstandardizedPosterior = \n            prior\n            |\u003E Array.zip likelihood\n            |\u003E Array.map (fun (ll, p) -\u003E ll * p)\n        \n        let sum = Array.sum unstandardizedPosterior\n        \n        unstandardizedPosterior \n        |\u003E Array.map (fun xs -\u003E xs / sum)\n\n    let binomialPosterior prior nTrials nSuccesses = \n        Generate.LinearSpaced(Seq.length prior, 0., 1.)\n        |\u003E Array.map (fun p -\u003E Binomial.PMF(p=p, n=nTrials, k=nSuccesses))\n        |\u003E posteriorProbabilities prior\n\n    let multiBinominalPosteriorFig priorFunc points nTrials nSuccesses = \n        points\n        |\u003E Seq.map (fun xs -\u003E \n            let probas = Generate.LinearSpaced(xs, 0., 1.)\n            let prior = probas|\u003E Array.map priorFunc\n            Chart.Line(probas, binomialPosterior prior nTrials nSuccesses, Name = $\u0022# Grid Points: {probas.Length}\u0022))\n        |\u003E Chart.combine\n        |\u003E Chart.withTitle(\u0022Grid approximation - Posterior Distribution\u0022)\n        |\u003E Chart.withXAxisStyle(\u0022Parameter p\u0022, MinMax=(0., 1.))\n        |\u003E Chart.withYAxisStyle(\u0022Posterior probability\u0022)\n        |\u003E Chart.withSize(1000., 500.)\n\nmodule NumpyUtils = \n    let toNDarray (xs : seq\u003C_\u003E) : NDarray = \n        np.asarray\u003C_\u003E(Seq.toArray xs)\n\n    let toSharp (xs : NDarray) : array\u003Cfloat\u003E = \n        xs.astype(np.float_).GetData\u003Cfloat\u003E()"}]